# -*- coding: utf-8 -*-
"""EDA_Assg_NYC_Taxi_Fazil_Ahmed.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/129KtL9ZZ_kNmdm7442fa0CFFU7HnT16J

**New York City Yellow Taxi Data**

## Objective
In this case study you will be learning exploratory data analysis (EDA) with the help of a dataset on yellow taxi rides in New York City. This will enable you to understand why EDA is an important step in the process of data science and machine learning.

## **Problem Statement**
As an analyst at an upcoming taxi operation in NYC, you are tasked to use the 2023 taxi trip data to uncover insights that could help optimise taxi operations. The goal is to analyse patterns in the data that can inform strategic decisions to improve service efficiency, maximise revenue, and enhance passenger experience.

## Tasks
You need to perform the following steps for successfully completing this assignment:
1. Data Loading
2. Data Cleaning
3. Exploratory Analysis: Bivariate and Multivariate
4. Creating Visualisations to Support the Analysis
5. Deriving Insights and Stating Conclusions

---

**NOTE:** The marks given along with headings and sub-headings are cumulative marks for those particular headings/sub-headings.<br>

The actual marks for each task are specified within the tasks themselves.

For example, marks given with heading *2* or sub-heading *2.1* are the cumulative marks, for your reference only. <br>

The marks you will receive for completing tasks are given with the tasks.

Suppose the marks for two tasks are: 3 marks for 2.1.1 and 2 marks for 3.2.2, or
* 2.1.1 [3 marks]
* 3.2.2 [2 marks]

then, you will earn 3 marks for completing task 2.1.1 and 2 marks for completing task 3.2.2.

---

## Data Understanding
The yellow taxi trip records include fields capturing pick-up and drop-off dates/times, pick-up and drop-off locations, trip distances, itemized fares, rate types, payment types, and driver-reported passenger counts.

The data is stored in Parquet format (*.parquet*). The dataset is from 2009 to 2024. However, for this assignment, we will only be using the data from 2023.

The data for each month is present in a different parquet file. You will get twelve files for each of the months in 2023.

The data was collected and provided to the NYC Taxi and Limousine Commission (TLC) by technology providers like vendors and taxi hailing apps. <br>

You can find the link to the TLC trip records page here: https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page

###  Data Description
You can find the data description here: [Data Dictionary](https://www.nyc.gov/assets/tlc/downloads/pdf/data_dictionary_trip_records_yellow.pdf)

**Trip Records**



|Field Name       |description |
|:----------------|:-----------|
| VendorID | A code indicating the TPEP provider that provided the record. <br> 1= Creative Mobile Technologies, LLC; <br> 2= VeriFone Inc. |
| tpep_pickup_datetime | The date and time when the meter was engaged.  |
| tpep_dropoff_datetime | The date and time when the meter was disengaged.   |
| Passenger_count | The number of passengers in the vehicle. <br> This is a driver-entered value. |
| Trip_distance | The elapsed trip distance in miles reported by the taximeter. |
| PULocationID | TLC Taxi Zone in which the taximeter was engaged |
| DOLocationID | TLC Taxi Zone in which the taximeter was disengaged |
|RateCodeID |The final rate code in effect at the end of the trip.<br> 1 = Standard rate <br> 2 = JFK <br> 3 = Newark <br>4 = Nassau or Westchester <br>5 = Negotiated fare <br>6 = Group ride |
|Store_and_fwd_flag |This flag indicates whether the trip record was held in vehicle memory before sending to the vendor, aka “store and forward,” because the vehicle did not have a connection to the server.  <br>Y= store and forward trip <br>N= not a store and forward trip |
|Payment_type| A numeric code signifying how the passenger paid for the trip. <br> 1 = Credit card <br>2 = Cash <br>3 = No charge <br>4 = Dispute <br>5 = Unknown <br>6 = Voided trip |
|Fare_amount| The time-and-distance fare calculated by the meter. <br>Extra Miscellaneous extras and surcharges.  Currently, this only includes the 0.50 and 1 USD rush hour and overnight charges. |
|MTA_tax |0.50 USD MTA tax that is automatically triggered based on the metered rate in use. |
|Improvement_surcharge | 0.30 USD improvement surcharge assessed trips at the flag drop. The improvement surcharge began being levied in 2015. |
|Tip_amount |Tip amount – This field is automatically populated for credit card tips. Cash tips are not included. |
| Tolls_amount | Total amount of all tolls paid in trip.  |
| total_amount | The total amount charged to passengers. Does not include cash tips. |
|Congestion_Surcharge |Total amount collected in trip for NYS congestion surcharge. |
| Airport_fee | 1.25 USD for pick up only at LaGuardia and John F. Kennedy Airports|

Although the amounts of extra charges and taxes applied are specified in the data dictionary, you will see that some cases have different values of these charges in the actual data.

**Taxi Zones**

Each of the trip records contains a field corresponding to the location of the pickup or drop-off of the trip, populated by numbers ranging from 1-263.

These numbers correspond to taxi zones, which may be downloaded as a table or map/shapefile and matched to the trip records using a join.

This is covered in more detail in later sections.

---

## **1** Data Preparation

<font color = red>[5 marks]</font> <br>

### Import Libraries
"""

# Import warnings

# Import the libraries you will be using for analysis

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Recommended versions
# numpy version: 1.26.4
# pandas version: 2.2.2
# matplotlib version: 3.10.0
# seaborn version: 0.13.2

# Check versions
print("numpy version:", np.__version__)
print("pandas version:", pd.__version__)
print("matplotlib version:", plt.matplotlib.__version__)
print("seaborn version:", sns.__version__)

"""### **1.1** Load the dataset
<font color = red>[5 marks]</font> <br>

You will see twelve files, one for each month.

To read parquet files with Pandas, you have to follow a similar syntax as that for CSV files.

`df = pd.read_parquet('file.parquet')`
"""

# Try loading one file

# df = pd.read_parquet('2023-1.parquet')
# df.info()

from google.colab import files
uploaded = files.upload()

df = pd.read_parquet("2023-1.parquet")  # Replace with actual filename
df.info()

"""How many rows are there? Do you think handling such a large number of rows is computationally feasible when we have to combine the data for all twelve months into one?

To handle this, we need to sample a fraction of data from each of the files. How to go about that? Think of a way to select only some portion of the data from each month's file that accurately represents the trends.

#### Sampling the Data
> One way is to take a small percentage of entries for pickup in every hour of a date. So, for all the days in a month, we can iterate through the hours and select 5% values randomly from those. Use `tpep_pickup_datetime` for this. Separate date and hour from the datetime values and then for each date, select some fraction of trips for each of the 24 hours.

To sample data, you can use the `sample()` method. Follow this syntax:

```Python
# sampled_data is an empty DF to keep appending sampled data of each hour
# hour_data is the DF of entries for an hour 'X' on a date 'Y'

sample = hour_data.sample(frac = 0.05, random_state = 42)
# sample 0.05 of the hour_data
# random_state is just a seed for sampling, you can define it yourself

sampled_data = pd.concat([sampled_data, sample]) # adding data for this hour to the DF
```

This *sampled_data* will contain 5% values selected at random from each hour.

Note that the code given above is only the part that will be used for sampling and not the complete code required for sampling and combining the data files.

Keep in mind that you sample by date AND hour, not just hour. (Why?)
"""

# Extracting  date and hour from pickup datetime
df['pickup_date'] = df['tpep_pickup_datetime'].dt.date
df['pickup_hour'] = df['tpep_pickup_datetime'].dt.hour

#Creating an empty DataFrame to hold all samples
sampled_data = pd.DataFrame()

# Iterate over each date
unique_dates = df['pickup_date'].unique()

for date in unique_dates:
    # For each hour in the 24-hour day
    for hour in range(24):
        # Get data for the specific hour of the date
        hour_data = df[(df['pickup_date'] == date) & (df['pickup_hour'] == hour)]

        # Only sample if data exists for that hour
        if not hour_data.empty:
            # Sample 5% of the data
            sample = hour_data.sample(frac=0.05, random_state=42)
            # Append to the sampled dataset
            sampled_data = pd.concat([sampled_data, sample], ignore_index=True)


print("Original dataset size:", len(df))
print("Sampled dataset size (5% per hour per date):", len(sampled_data))

"""---

**1.1.1** <font color = red>[5 marks]</font> <br>
Figure out how to sample and combine the files.

**Note:** It is not mandatory to use the method specified above. While sampling, you only need to make sure that your sampled data represents the overall data of all the months accurately.
"""

# Sample the data
# It is recommmended to not load all the files at once to avoid memory overload

# from google.colab import drive
# drive.mount('/content/drive')

# Take a small percentage of entries from each hour of every date.
# Iterating through the monthly data:
#   read a month file -> day -> hour: append sampled data -> move to next hour -> move to next day after 24 hours -> move to next month file
# Create a single dataframe for the year combining all the monthly data

# Select the folder having data files
import pandas as pd
import os
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Define the path to the folder where your .parquet files are stored
data_folder_path = '/content/drive/MyDrive/Upgrad/EDA_NYC_TAXI'

# List files inside that folder
file_list = sorted(os.listdir(data_folder_path))  # Ensure files are sorted by month

# Initialize empty DataFrame to collect sampled data
df_yearly_sample = pd.DataFrame()

# Loop through all monthly files
for file_name in file_list:
    try:
        print(f"📁 Processing: {file_name}")
        file_path = os.path.join(data_folder_path, file_name)

        # Load the month's data
        df_month = pd.read_parquet(file_path)

        # Ensure datetime is in correct format
        df_month['tpep_pickup_datetime'] = pd.to_datetime(df_month['tpep_pickup_datetime'])

        # Extract date and hour
        df_month['pickup_date'] = df_month['tpep_pickup_datetime'].dt.date
        df_month['pickup_hour'] = df_month['tpep_pickup_datetime'].dt.hour

        # Initialize container for this month's sampled data
        sampled_month = pd.DataFrame()

        # Loop through each date and hour
        for date in df_month['pickup_date'].unique():
            for hour in range(24):
                hour_data = df_month[(df_month['pickup_date'] == date) & (df_month['pickup_hour'] == hour)]
                if not hour_data.empty:
                    sample = hour_data.sample(frac=0.05, random_state=42)
                    sampled_month = pd.concat([sampled_month, sample], ignore_index=True)

        # Append to final yearly sample
        df_yearly_sample = pd.concat([df_yearly_sample, sampled_month], ignore_index=True)
        print(f"✅ {file_name} done | Sampled: {len(sampled_month)} rows")

    except Exception as e:
        print(f"❌ Error processing {file_name}: {e}")

# Done!
print(f"\n🎉 Sampling complete! Total sampled rows for the year: {len(df_yearly_sample)}")

df_yearly_sample.to_parquet('/content/drive/MyDrive/Upgrad/EDA_NYC_TAXI/sample_2023.parquet')

"""After combining the data files into one DataFrame, convert the new DataFrame to a CSV or parquet file and store it to use directly.

Ideally, you can try keeping the total entries to around 250,000 to 300,000.
"""

# Store the df in csv/parquet
# df.to_parquet('')
df_yearly_sample.to_parquet('/content/drive/MyDrive/Upgrad/EDA_NYC_TAXI/sample_2023.parquet')

"""## **2** Data Cleaning
<font color = red>[30 marks]</font> <br>

Now we can load the new data directly.
"""

# Load the new data file

import pandas as pd

# Load the saved sampled dataset
df = pd.read_parquet('/content/drive/MyDrive/Upgrad/EDA_NYC_TAXI/sample_2023.parquet')

# df.head()
df.head()

# df.info()
df.info()

"""#### **2.1** Fixing Columns
<font color = red>[10 marks]</font> <br>

Fix/drop any columns as you seem necessary in the below sections

**2.1.1** <font color = red>[2 marks]</font> <br>

Fix the index and drop unnecessary columns
"""

# Fix the index and drop any columns that are not needed

# Step 1: Reset the index
df = df.reset_index(drop=True)


columns_to_drop = []


if df['store_and_fwd_flag'].nunique() == 1:
    columns_to_drop.append('store_and_fwd_flag')


df = df.drop(columns=columns_to_drop)

# Confirm changes
print("Updated columns:", df.columns.tolist())

"""**2.1.2** <font color = red>[3 marks]</font> <br>
There are two airport fee columns. This is possibly an error in naming columns. Let's see whether these can be combined into a single column.
"""

# Combine the two airport fee columns

# Check if both columns still exist
[df.columns for col in df.columns if 'airport_fee' in col.lower()]

# Compare values to see if they are the same
df[['airport_fee', 'Airport_fee']].dropna().head()
(df['airport_fee'] == df['Airport_fee']).value_counts(dropna=False)

df.columns.tolist()

if 'Airport_fee' in df.columns:
    df['airport_fee'] = df['airport_fee'].fillna(df['Airport_fee'])
    df = df.drop(columns=['Airport_fee'])  # drop the duplicate

print(df[['airport_fee']].describe())

"""**2.1.3** <font color = red>[5 marks]</font> <br>
Fix columns with negative (monetary) values
"""

monetary_cols = [
    'fare_amount',
    'extra',
    'mta_tax',
    'tip_amount',
    'tolls_amount',
    'improvement_surcharge',
    'total_amount',
    'congestion_surcharge',
    'airport_fee',
    'RatecodeID'
]

# check where values of fare amount are negative

negative_fares = df[df['fare_amount'] < 0]
print(f"Rows with negative fare_amount: {len(negative_fares)}")

# View a few of these rows
negative_fares[['fare_amount', 'RatecodeID', 'trip_distance', 'total_amount']].head()

"""Did you notice something different in the `RatecodeID` column for above records?"""

# Analyse RatecodeID for the negative fare amounts

print("RatecodeID distribution for negative fares:")
print(negative_fares['RatecodeID'].value_counts(dropna=False))

# Find which columns have negative values

# Define monetary columns
monetary_cols = [
    'fare_amount',
    'extra',
    'mta_tax',
    'tip_amount',
    'tolls_amount',
    'improvement_surcharge',
    'total_amount',
    'congestion_surcharge',
    'airport_fee'
]

# Check for negatives
for col in monetary_cols:
    if col in df.columns:
        neg_count = (df[col] < 0).sum()
        if neg_count > 0:
            print(f"{col}: {neg_count} negative values")

# fix these negative values

# Drop rows with negative values in any monetary column
for col in monetary_cols:
    if col in df.columns:
        df = df[df[col] >= 0]

"""### **2.2** Handling Missing Values
<font color = red>[10 marks]</font> <br>

**2.2.1**  <font color = red>[2 marks]</font> <br>
Find the proportion of missing values in each column
"""

# Find the proportion of missing values in each column

missing_percent = df.isnull().mean().sort_values(ascending=False) * 100
print(missing_percent[missing_percent > 0])

df.isnull()

"""**2.2.2**  <font color = red>[3 marks]</font> <br>
Handling missing values in `passenger_count`
"""

# Display the rows with null values
# Impute NaN values in 'passenger_count'
null_passenger_rows = df[df['passenger_count'].isnull()]
print(null_passenger_rows)

"""Did you find zeroes in passenger_count? Handle these."""

zero_passenger_trips = df[df['passenger_count'] == 0]
print(f"Number of trips with 0 passengers: {len(zero_passenger_trips)}")

zero_passenger_stats = df[df['passenger_count'] == 0].describe()
print(zero_passenger_stats[['trip_distance', 'fare_amount', 'total_amount']])

#Keep Trips with Valid Distance/Fare, Fix Zero Passengers
df['passenger_count'] = df['passenger_count'].replace(0, 1)

# Drop Trips with Zero Distance/Fare (Likely Cancellations)
df = df[~((df['trip_distance'] == 0) & (df['fare_amount'] == 0))]

#Verify Distribution Post-Cleaning
print("New passenger count distribution:\n", df['passenger_count'].value_counts())
df[['trip_distance', 'fare_amount']].describe()  # Check cleaned stats

"""**2.2.3**  <font color = red>[2 marks]</font> <br>
Handle missing values in `RatecodeID`
"""

# Fix missing values in 'RatecodeID'
# Check for missing values in 'RatecodeID'
missing_ratecode = df['RatecodeID'].isnull().sum()
print(f"Number of missing values in RatecodeID: {missing_ratecode}")

# Confirm no missing values remain
assert df['RatecodeID'].isnull().sum() == 0, "Missing values still exist!"
print("Missing values in RatecodeID after handling:", df['RatecodeID'].isnull().sum())

"""**2.2.4**  <font color = red>[3 marks]</font> <br>
Impute NaN in `congestion_surcharge`
"""

# handle null values in congestion_surcharge

missing_congestion = df['congestion_surcharge'].isnull().sum()
print(f"Number of missing values in congestion_surcharge: {missing_congestion}")

"""Are there missing values in other columns? Did you find NaN values in some other set of columns? Handle those missing values below."""

# Handle any remaining missing values

missing_values = df.isnull().sum()
missing_values = missing_values[missing_values > 0]
print("Columns with missing values:\n", missing_values)

non_standard_missing = {
    'trip_distance': (df['trip_distance'] <= 0).sum(),
    'fare_amount': (df['fare_amount'] <= 0).sum(),
    'RatecodeID': (~df['RatecodeID'].isin([1, 2, 3, 4, 5, 6])).sum()
}
print("Non-standard 'missing' values:\n", non_standard_missing)

# Replace zeros/negatives with median (for numeric columns)
df['trip_distance'] = df['trip_distance'].replace(0, df['trip_distance'].median())
df['fare_amount'] = df['fare_amount'].replace(0, df['fare_amount'].median())

print("Data completeness confirmed. Remaining missing values:", df.isnull().sum().sum())

"""### **2.3** Handling Outliers
<font color = red>[10 marks]</font> <br>

Before we start fixing outliers, let's perform outlier analysis.
"""

# Describe the data and check if there are any potential outliers present
# Check for potential out of place values in various columns

import pandas as pd
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Define the path to the folder where your .parquet files are stored
data_folder_path = '/content/drive/MyDrive/Upgrad/EDA_NYC_TAXI'

# Load the cleaned and sampled dataset
df = pd.read_parquet('/content/drive/MyDrive/Upgrad/EDA_NYC_TAXI/sample_2023.parquet')

df.describe()

# Function to count outliers using IQR method
def count_outliers(series):
    Q1 = series.quantile(0.25)
    Q3 = series.quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - 1.5 * IQR
    upper = Q3 + 1.5 * IQR
    return ((series < lower) | (series > upper)).sum()

columns_to_check = ['trip_distance', 'fare_amount', 'total_amount', 'tip_amount', 'passenger_count']

for col in columns_to_check:
    if col in df.columns:
        outlier_count = count_outliers(df[col])
        print(f"{col}: {outlier_count} outliers")

"""**2.3.1**  <font color = red>[10 marks]</font> <br>
Based on the above analysis, it seems that some of the outliers are present due to errors in registering the trips. Fix the outliers.

Some points you can look for:
- Entries where `trip_distance` is nearly 0 and `fare_amount` is more than 300
- Entries where `trip_distance` and `fare_amount` are 0 but the pickup and dropoff zones are different (both distance and fare should not be zero for different zones)
- Entries where `trip_distance` is more than 250  miles.
- Entries where `payment_type` is 0 (there is no payment_type 0 defined in the data dictionary)

These are just some suggestions. You can handle outliers in any way you wish, using the insights from above outlier analysis.

How will you fix each of these values? Which ones will you drop and which ones will you replace?

First, let us remove 7+ passenger counts as there are very less instances.
"""

# remove passenger_count > 6
# Drop rows with passenger_count > 6 (rare and potentially erroneous)
df = df[df['passenger_count'] <= 6]
print("Trips after removing 7+ passengers:", len(df))

# Continue with outlier handling

df = df[~((df['trip_distance'] < 0.1) & (df['fare_amount'] > 300))]

df = df[df['trip_distance'] <= 250]

df = df[df['payment_type'] != 0]

# Do any columns need standardising?

print("Shape after removing outliers:", df.shape)

"""## **3** Exploratory Data Analysis
<font color = red>[90 marks]</font> <br>
"""

df.columns.tolist()

"""#### **3.1** General EDA: Finding Patterns and Trends
<font color = red>[40 marks]</font> <br>

**3.1.1** <font color = red>[3 marks]</font> <br>
Categorise the varaibles into Numerical or Categorical.
* `VendorID`:
* `tpep_pickup_datetime`:
* `tpep_dropoff_datetime`:
* `passenger_count`:
* `trip_distance`:
* `RatecodeID`:
* `PULocationID`:
* `DOLocationID`:
* `payment_type`:
* `pickup_hour`:
* `trip_duration`:


The following monetary parameters belong in the same category, is it categorical or numerical?


* `fare_amount`
* `extra`
* `mta_tax`
* `tip_amount`
* `tolls_amount`
* `improvement_surcharge`
* `total_amount`
* `congestion_surcharge`
* `airport_fee`

##### Temporal Analysis

For temporal analysis, you would typically examine:

Hourly patterns: Trip frequency by hour of day

Daily/Weekly trends: Variation by day of week

Seasonal patterns: Monthly/quarterly variations

Duration trends: How trip durations vary by time of day

Fare patterns: How fares fluctuate temporally

**3.1.2** <font color = red>[5 marks]</font> <br>
Analyse the distribution of taxi pickups by hours, days of the week, and months.
"""

# Find and show the hourly trends in taxi pickups

import seaborn as sns
import matplotlib.pyplot as plt

# Hourly trend
sns.countplot(x='pickup_hour', data=df, palette='viridis')
plt.title("Taxi Pickups by Hour of Day")
plt.xlabel("Hour of Day (0–23)")
plt.ylabel("Number of Pickups")
plt.show()

# Find and show the daily trends in taxi pickups (days of the week)

# Extract day of week from pickup datetime
df['pickup_day'] = pd.to_datetime(df['tpep_pickup_datetime']).dt.day_name()

# Plot
sns.countplot(x='pickup_day', data=df, order=['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'], palette='coolwarm')
plt.title("Taxi Pickups by Day of Week")
plt.xlabel("Day of Week")
plt.ylabel("Number of Pickups")
plt.show()

# Show the monthly trends in pickups

# Extract month
df['pickup_month'] = pd.to_datetime(df['tpep_pickup_datetime']).dt.month_name()

# Monthly order
month_order = ['January', 'February', 'March', 'April', 'May', 'June',
               'July', 'August', 'September', 'October', 'November', 'December']

sns.countplot(x='pickup_month', data=df, order=month_order, palette='Set2')
plt.title("Taxi Pickups by Month")
plt.xlabel("Month")
plt.ylabel("Number of Pickups")
plt.xticks(rotation=45)
plt.show()

"""##### Financial Analysis"""

cols_to_check = ['fare_amount', 'tip_amount', 'total_amount', 'trip_distance']

for col in cols_to_check:
    zero_count = (df[col] == 0).sum()
    neg_count = (df[col] < 0).sum()
    print(f"{col}: {zero_count} zeroes, {neg_count} negative values")

"""Take a look at the financial parameters like `fare_amount`, `tip_amount`, `total_amount`, and also `trip_distance`. Do these contain zero/negative values?"""

# Analyse the above parameters

# Create a filtered copy without zeroes in key numeric fields
df_financial = df[(df['fare_amount'] > 0) &
                  (df['total_amount'] > 0) &
                  (df['trip_distance'] > 0)]

"""Do you think it is beneficial to create a copy DataFrame leaving out the zero values from these?

Analyzed hourly, daily, and monthly pickup trends.

Found peak activity during commute hours and weekends.

Detected zero or negative values in fare_amount, total_amount, and trip_distance.

Created a cleaned subset for financial analysis excluding 0/negative values.

**3.1.3** <font color = red>[2 marks]</font> <br>
Filter out the zero values from the above columns.

**Note:** The distance might be 0 in cases where pickup and drop is in the same zone. Do you think it is suitable to drop such cases of zero distance?
"""

# Create a df with non zero entries for the selected parameters.

# Create a copy excluding zero values for key financial fields
df_financial = df[(df['fare_amount'] > 0) &
                  (df['total_amount'] > 0) &
                  (df['trip_distance'] > 0)]

print(f"Filtered data shape: {df_financial.shape}")

"""**3.1.4** <font color = red>[3 marks]</font> <br>
Analyse the monthly revenue (`total_amount`) trend
"""

# Group data by month and analyse monthly revenue

# Add pickup month
df_financial['month'] = pd.to_datetime(df_financial['tpep_pickup_datetime']).dt.month_name()

# Group by month and sum total_amount
monthly_revenue = df_financial.groupby('month')['total_amount'].sum().reindex(
    ['January', 'February', 'March', 'April', 'May', 'June',
     'July', 'August', 'September', 'October', 'November', 'December'])

# Plot
monthly_revenue.plot(kind='bar', color='steelblue', title='Monthly Revenue from Taxi Rides')
plt.ylabel("Total Revenue ($)")
plt.xlabel("Month")
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.show()

"""**3.1.5** <font color = red>[3 marks]</font> <br>
Show the proportion of each quarter of the year in the revenue
"""

# Calculate proportion of each quarter

# Extract quarter
df_financial['quarter'] = pd.to_datetime(df_financial['tpep_pickup_datetime']).dt.quarter

# Revenue by quarter
quarterly_revenue = df_financial.groupby('quarter')['total_amount'].sum()
quarterly_revenue_pct = (quarterly_revenue / quarterly_revenue.sum()) * 100

# Pie chart
quarterly_revenue_pct.plot(kind='pie', autopct='%1.1f%%', startangle=90, title='Revenue Share by Quarter')
plt.ylabel("")
plt.show()

"""**3.1.6** <font color = red>[3 marks]</font> <br>
Visualise the relationship between `trip_distance` and `fare_amount`. Also find the correlation value for these two.

**Hint:** You can leave out the trips with trip_distance = 0
"""

# Show how trip fare is affected by distance

import seaborn as sns

# Scatter plot
sns.scatterplot(data=df_financial, x='trip_distance', y='fare_amount', alpha=0.5)
plt.title("Fare vs Trip Distance")
plt.xlabel("Trip Distance (miles)")
plt.ylabel("Fare Amount ($)")
plt.show()

# Correlation
correlation = df_financial['trip_distance'].corr(df_financial['fare_amount'])
print(f"Correlation between trip distance and fare amount: {correlation:.2f}")

"""**3.1.7** <font color = red>[5 marks]</font> <br>
Find and visualise the correlation between:
1. `fare_amount` and trip duration (pickup time to dropoff time)
2. `fare_amount` and `passenger_count`
3. `tip_amount` and `trip_distance`
"""

df_financial['trip_duration'] = (
    pd.to_datetime(df_financial['tpep_dropoff_datetime']) -
    pd.to_datetime(df_financial['tpep_pickup_datetime'])
).dt.total_seconds() / 60  # minutes

# Show relationship between fare and trip duration

sns.scatterplot(data=df_financial, x='trip_duration', y='fare_amount', alpha=0.5)
plt.title("Fare vs Trip Duration (minutes)")
plt.xlabel("Duration")
plt.ylabel("Fare Amount")
plt.show()

print("Correlation (fare vs duration):", df_financial['trip_duration'].corr(df_financial['fare_amount']))

# Show relationship between fare and number of passengers

sns.boxplot(data=df_financial, x='passenger_count', y='fare_amount')
plt.title("Fare vs Passenger Count")
plt.xlabel("Passenger Count")
plt.ylabel("Fare Amount")
plt.show()

print("Correlation (fare vs passengers):", df_financial['passenger_count'].corr(df_financial['fare_amount']))

# Show relationship between tip and trip distance
sns.scatterplot(data=df_financial, x='trip_distance', y='tip_amount', alpha=0.4)
plt.title("Tip vs Trip Distance")
plt.xlabel("Distance")
plt.ylabel("Tip Amount")
plt.show()

print("Correlation (tip vs distance):", df_financial['trip_distance'].corr(df_financial['tip_amount']))

"""**3.1.8** <font color = red>[3 marks]</font> <br>
Analyse the distribution of different payment types (`payment_type`)
"""

# Analyse the distribution of different payment types (payment_type).

# Map payment type codes (optional)
payment_map = {
    1: 'Credit Card',
    2: 'Cash',
    3: 'No Charge',
    4: 'Dispute',
    5: 'Unknown',
    6: 'Voided Trip'
}
df_financial['payment_type_label'] = df_financial['payment_type'].map(payment_map)

sns.countplot(data=df_financial, x='payment_type_label', order=df_financial['payment_type_label'].value_counts().index)
plt.title("Distribution of Payment Types")
plt.xticks(rotation=45)
plt.xlabel("Payment Type")
plt.ylabel("Number of Trips")
plt.show()

"""- 1= Credit card
- 2= Cash
- 3= No charge
- 4= Dispute

##### Geographical Analysis
"""

# Top 10 pickup locations
top_pu = df_financial['PULocationID'].value_counts().head(10)

# Bar plot
top_pu.plot(kind='bar', color='darkorange', title='Top 10 Pickup Zones')
plt.xlabel("Pickup Location ID")
plt.ylabel("Number of Pickups")
plt.show()

"""For this, you have to use the *taxi_zones.shp* file from the *taxi_zones* folder.

There would be multiple files inside the folder (such as *.shx, .sbx, .sbn* etc). You do not need to import/read any of the files other than the shapefile, *taxi_zones.shp*.

Do not change any folder structure - all the files need to be present inside the folder for it to work.

The folder structure should look like this:
```
Taxi Zones
|- taxi_zones.shp.xml
|- taxi_zones.prj
|- taxi_zones.sbn
|- taxi_zones.shp
|- taxi_zones.dbf
|- taxi_zones.shx
|- taxi_zones.sbx

 ```

 You only need to read the `taxi_zones.shp` file. The *shp* file will utilise the other files by itself.

We will use the *GeoPandas* library for geopgraphical analysis
```
import geopandas as gpd
```

More about geopandas and shapefiles: [About](https://geopandas.org/en/stable/about.html)


Reading the shapefile is very similar to *Pandas*. Use `gpd.read_file()` function to load the data (*taxi_zones.shp*) as a GeoDataFrame. Documentation: [Reading and Writing Files](https://geopandas.org/en/stable/docs/user_guide/io.html)
"""

# !pip install geopandas
!pip install geopandas

"""**3.1.9** <font color = red>[2 marks]</font> <br>
Load the shapefile and display it.
"""

# import geopandas as gpd

import geopandas as gpd
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Load the shapefile (adjust path if needed)
zones = gpd.read_file('/content/drive/MyDrive/Upgrad/taxi_zones')
# Read the shapefile using geopandas
zones.head()

"""Now, if you look at the DataFrame created, you will see columns like: `OBJECTID`,`Shape_Leng`, `Shape_Area`, `zone`, `LocationID`, `borough`, `geometry`.
<br><br>

Now, the `locationID` here is also what we are using to mark pickup and drop zones in the trip records.

The geometric parameters like shape length, shape area and geometry are used to plot the zones on a map.

This can be easily done using the `plot()` method.
"""

print(zones.info())
zones.plot()

"""Now, you have to merge the trip records and zones data using the location IDs.

**3.1.10** <font color = red>[3 marks]</font> <br>
Merge the zones data into trip data using the `locationID` and `PULocationID` columns.
"""

# Merge zones and trip records using locationID and PULocationID

# Merge GeoDataFrame with trip data on PULocationID and LocationID
merged_df = df_financial.merge(zones, left_on='PULocationID', right_on='LocationID', how='left')

# Preview the merged DataFrame
merged_df[['PULocationID', 'zone', 'borough']].head()

"""**3.1.11** <font color = red>[3 marks]</font> <br>
Group data by location IDs to find the total number of trips per location ID
"""

# Group data by location and calculate the number of trips

# Count number of trips per pickup location
trip_counts = df_financial.groupby('PULocationID').size().reset_index(name='trip_count')
trip_counts.head()

"""**3.1.12** <font color = red>[2 marks]</font> <br>
Now, use the grouped data to add number of trips to the GeoDataFrame.

We will use this to plot a map of zones showing total trips per zone.
"""

# Merge trip counts back to the zones GeoDataFrame

# Merge trip counts back to zones GeoDataFrame using LocationID
zones = zones.merge(trip_counts, left_on='LocationID', right_on='PULocationID', how='left')

# Fill missing trip counts with 0
zones['trip_count'] = zones['trip_count'].fillna(0)

# Optional: preview top zones
zones.sort_values('trip_count', ascending=False).head()

"""The next step is creating a color map (choropleth map) showing zones by the number of trips taken.

Again, you can use the `zones.plot()` method for this. [Plot Method GPD](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.plot.html#geopandas.GeoDataFrame.plot)

But first, you need to define the figure and axis for the plot.

`fig, ax = plt.subplots(1, 1, figsize = (12, 10))`

This function creates a figure (fig) and a single subplot (ax)

---

After setting up the figure and axis, we can proceed to plot the GeoDataFrame on this axis. This is done in the next step where we use the plot method of the GeoDataFrame.

You can define the following parameters in the `zones.plot()` method:
```
column = '',
ax = ax,
legend = True,
legend_kwds = {'label': "label", 'orientation': "<horizontal/vertical>"}
```

To display the plot, use `plt.show()`.

**3.1.13** <font color = red>[3 marks]</font> <br>
Plot a color-coded map showing zone-wise trips
"""

# Define figure and axis

import matplotlib.pyplot as plt

# Create figure and axis
fig, ax = plt.subplots(1, 1, figsize=(12, 10))

# Plot choropleth
zones.plot(column='trip_count',
           ax=ax,
           cmap='OrRd',
           legend=True,
           legend_kwds={'label': "Total Trips per Zone", 'orientation': "vertical"})

# Set title
plt.title("NYC Taxi Trips by Pickup Zone (2023 Sample)", fontsize=14)
plt.axis('off')
plt.show()

# Plot the map and display it

# can you try displaying the zones DF sorted by the number of trips?

Loaded NYC taxi zone shapefile using GeoPandas.

Merged trip data with zone polygons using PULocationID.

Grouped data to calculate total pickups per zone.

Mapped the data on a choropleth showing high-demand areas like Manhattan and JFK.

This visualization helps identify taxi hot-spots and underserved regions.

"""Here we have completed the temporal, financial and geographical analysis on the trip records.

**Compile your findings from general analysis below:**

You can consider the following points:

* Busiest hours, days and months
* Trends in revenue collected
* Trends in quarterly revenue
* How fare depends on trip distance, trip duration and passenger counts
* How tip amount depends on trip distance
* Busiest zones

#### **3.2** Detailed EDA: Insights and Strategies
<font color = red>[50 marks]</font> <br>

Having performed basic analyses for finding trends and patterns, we will now move on to some detailed analysis focussed on operational efficiency, pricing strategies, and customer experience.

##### Operational Efficiency

Analyze variations by time of day and location to identify bottlenecks or inefficiencies in routes

**3.2.1** <font color = red>[3 marks]</font> <br>
Identify slow routes by calculating the average time taken by cabs to get from one zone to another at different hours of the day.

Speed on a route *X* for hour *Y* = (*distance of the route X / average trip duration for hour Y*)
"""

# Find routes which have the slowest speeds at different times of the day
# First, compute trip duration in minutes
df_financial['trip_duration'] = (
    pd.to_datetime(df_financial['tpep_dropoff_datetime']) -
    pd.to_datetime(df_financial['tpep_pickup_datetime'])
).dt.total_seconds() / 60

# Filter out durations <= 0 to avoid invalid cases
df_valid_speed = df_financial[df_financial['trip_duration'] > 0]

# Group by pickup + dropoff + hour
avg_speed_df = df_valid_speed.groupby(['PULocationID', 'DOLocationID', 'pickup_hour']).agg({
    'trip_distance': 'mean',
    'trip_duration': 'mean'
}).reset_index()

# Calculate speed in miles per minute (or multiply by 60 for mph)
avg_speed_df['speed_mph'] = (avg_speed_df['trip_distance'] / avg_speed_df['trip_duration']) * 60

# Find slowest routes
slowest_routes = avg_speed_df.sort_values('speed_mph').head(10)
slowest_routes

"""How does identifying high-traffic, high-demand routes help us?

**3.2.2** <font color = red>[3 marks]</font> <br>
Calculate the number of trips at each hour of the day and visualise them. Find the busiest hour and show the number of trips for that hour.
"""

# Visualise the number of trips per hour and find the busiest hour

import seaborn as sns
import matplotlib.pyplot as plt

# Group by pickup_hour
hourly_trips = df_financial['pickup_hour'].value_counts().sort_index()

# Visualize
sns.barplot(x=hourly_trips.index, y=hourly_trips.values)
plt.title("Number of Taxi Pickups per Hour")
plt.xlabel("Hour of Day")
plt.ylabel("Number of Pickups (Sampled)")
plt.show()

# Busiest hour
busiest_hour = hourly_trips.idxmax()
busiest_hour_count = hourly_trips.max()
print(f"Busiest Hour: {busiest_hour} | Trips: {busiest_hour_count}")

"""Remember, we took a fraction of trips. To find the actual number, you have to scale the number up by the sampling ratio.

**3.2.3** <font color = red>[2 mark]</font> <br>
Find the actual number of trips in the five busiest hours
"""

# Scale up the number of trips

# Fill in the value of your sampling fraction and use that to scale up the numbers
#sample_fraction =

sample_fraction = 0.05  # You used 5% sampling

# Top 5 busiest hours
top5_hours = hourly_trips.sort_values(ascending=False).head(5)
top5_scaled = (top5_hours / sample_fraction).astype(int)

print("Estimated Actual Trips for Top 5 Hours:")
print(top5_scaled)

"""**3.2.4** <font color = red>[3 marks]</font> <br>
Compare hourly traffic pattern on weekdays. Also compare for weekend.
"""

# Compare traffic trends for the week days and weekends

# Extract weekday
df_financial['pickup_day'] = pd.to_datetime(df_financial['tpep_pickup_datetime']).dt.day_name()
df_financial['is_weekend'] = df_financial['pickup_day'].isin(['Saturday', 'Sunday'])

# Plot hourly patterns
sns.histplot(data=df_financial, x='pickup_hour', hue='is_weekend', multiple='stack', bins=24)
plt.title("Hourly Pickup Comparison: Weekdays vs Weekends")
plt.xlabel("Hour of Day")
plt.ylabel("Number of Pickups")
plt.legend(["Weekday", "Weekend"])
plt.show()

"""What can you infer from the above patterns? How will finding busy and quiet hours for each day help us?

**3.2.5** <font color = red>[3 marks]</font> <br>
Identify top 10 zones with high hourly pickups. Do the same for hourly dropoffs. Show pickup and dropoff trends in these zones.
"""

# Find top 10 pickup and dropoff zones

top_pu_zones = df_financial['PULocationID'].value_counts().head(10)
top_do_zones = df_financial['DOLocationID'].value_counts().head(10)

# Visualize
top_pu_zones.plot(kind='bar', color='skyblue', title='Top 10 Pickup Zones')
plt.xlabel('Zone ID')
plt.ylabel('Pickups')
plt.show()

top_do_zones.plot(kind='bar', color='salmon', title='Top 10 Dropoff Zones')
plt.xlabel('Zone ID')
plt.ylabel('Dropoffs')
plt.show()

"""**3.2.6** <font color = red>[3 marks]</font> <br>
Find the ratio of pickups and dropoffs in each zone. Display the 10 highest (pickup/drop) and 10 lowest (pickup/drop) ratios.
"""

# Find the top 10 and bottom 10 pickup/dropoff ratios

pickup_counts = df_financial['PULocationID'].value_counts()
dropoff_counts = df_financial['DOLocationID'].value_counts()

# Create a ratio DataFrame
ratios_df = pd.DataFrame({
    'pickup': pickup_counts,
    'dropoff': dropoff_counts
}).fillna(0)

ratios_df['pickup_drop_ratio'] = ratios_df['pickup'] / (ratios_df['dropoff'] + 1)

# Top & Bottom 10
top_ratios = ratios_df.sort_values('pickup_drop_ratio', ascending=False).head(10)
bottom_ratios = ratios_df.sort_values('pickup_drop_ratio', ascending=True).head(10)

print("Top 10 Pickup/Dropoff Ratios:\n", top_ratios)
print("\nBottom 10 Pickup/Dropoff Ratios:\n", bottom_ratios)

"""**3.2.7** <font color = red>[3 marks]</font> <br>
Identify zones with high pickup and dropoff traffic during night hours (11PM to 5AM)
"""

# During night hours (11pm to 5am) find the top 10 pickup and dropoff zones
# Note that the top zones should be of night hours and not the overall top zones

night_df = df_financial[(df_financial['pickup_hour'] >= 23) | (df_financial['pickup_hour'] <= 5)]

night_pu = night_df['PULocationID'].value_counts().head(10)
night_do = night_df['DOLocationID'].value_counts().head(10)

print("Top 10 Nighttime Pickup Zones:\n", night_pu)
print("\nTop 10 Nighttime Dropoff Zones:\n", night_do)

"""Now, let us find the revenue share for the night time hours and the day time hours. After this, we will move to deciding a pricing strategy.

**3.2.8** <font color = red>[2 marks]</font> <br>
Find the revenue share for nighttime and daytime hours.
"""

# Filter for night hours (11 PM to 5 AM)

night_revenue = night_df['total_amount'].sum()
day_revenue = df_financial[~((df_financial['pickup_hour'] >= 23) | (df_financial['pickup_hour'] <= 5))]['total_amount'].sum()

total = night_revenue + day_revenue
print(f"Night Revenue Share: {night_revenue / total:.2%}")
print(f"Day Revenue Share: {day_revenue / total:.2%}")

"""##### Pricing Strategy

**3.2.9** <font color = red>[2 marks]</font> <br>
For the different passenger counts, find the average fare per mile per passenger.

For instance, suppose the average fare per mile for trips with 3 passengers is 3 USD/mile, then the fare per mile per passenger will be 1 USD/mile.
"""

# Analyse the fare per mile per passenger for different passenger counts

# Filter valid trips
valid_fare = df_financial[(df_financial['trip_distance'] > 0) & (df_financial['passenger_count'] > 0)]

# Compute fare per mile per passenger
valid_fare['fare_per_mile_per_passenger'] = valid_fare['fare_amount'] / valid_fare['trip_distance'] / valid_fare['passenger_count']

# Group by passenger count
ppc_analysis = valid_fare.groupby('passenger_count')['fare_per_mile_per_passenger'].mean()
print("Fare per mile per passenger:\n", ppc_analysis)

"""**3.2.10** <font color = red>[3 marks]</font> <br>
Find the average fare per mile by hours of the day and by days of the week
"""

# Compare the average fare per mile for different days and for different times of the day

# Fare per mile
df_financial['fare_per_mile'] = df_financial['fare_amount'] / df_financial['trip_distance']

# By hour
hourly_fare = df_financial.groupby('pickup_hour')['fare_per_mile'].mean()
hourly_fare.plot(title='Average Fare per Mile by Hour', ylabel='Fare per Mile')
plt.show()

# By weekday
weekday_fare = df_financial.groupby('pickup_day')['fare_per_mile'].mean().reindex(
    ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
)
weekday_fare.plot(kind='bar', title='Average Fare per Mile by Day of Week', ylabel='Fare per Mile')
plt.show()

"""**3.2.11** <font color = red>[3 marks]</font> <br>
Analyse the average fare per mile for the different vendors for different hours of the day
"""

# Compare fare per mile for different vendors

vendor_hour_fare = df_financial.groupby(['VendorID', 'pickup_hour'])['fare_per_mile'].mean().unstack(0)

# Plot for each vendor
vendor_hour_fare.plot(title='Fare per Mile by Vendor and Hour')
plt.ylabel('Fare per Mile')
plt.xlabel('Hour of Day')
plt.legend(title='Vendor ID')
plt.show()

"""**3.2.12** <font color = red>[5 marks]</font> <br>
Compare the fare rates of the different vendors in a tiered fashion. Analyse the average fare per mile for distances upto 2 miles. Analyse the fare per mile for distances from 2 to 5 miles. And then for distances more than 5 miles.

"""

# Defining distance tiers

def fare_tier(row):
    if row['trip_distance'] <= 2:
        return '0–2 miles'
    elif row['trip_distance'] <= 5:
        return '2–5 miles'
    else:
        return '5+ miles'

df_financial['distance_tier'] = df_financial.apply(fare_tier, axis=1)

# Average fare per mile by vendor and distance tier
tiered_fare = df_financial.groupby(['VendorID', 'distance_tier'])['fare_per_mile'].mean().unstack()

print("Tiered fare per mile by vendor:\n", tiered_fare)

"""##### Customer Experience and Other Factors

**3.2.13** <font color = red>[5 marks]</font> <br>
Analyse average tip percentages based on trip distances, passenger counts and time of pickup. What factors lead to low tip percentages?
"""

#  Analyze tip percentages based on distances, passenger counts and pickup times
# Tip percentage
df_financial['tip_pct'] = (df_financial['tip_amount'] / df_financial['fare_amount']) * 100

# Tip vs Distance
sns.boxplot(x='distance_tier', y='tip_pct', data=df_financial)
plt.title("Tip % vs Trip Distance Tier")
plt.show()

# Tip vs Passenger Count
sns.boxplot(x='passenger_count', y='tip_pct', data=df_financial)
plt.title("Tip % vs Passenger Count")
plt.show()

# Tip vs Pickup Hour
sns.boxplot(x='pickup_hour', y='tip_pct', data=df_financial)
plt.title("Tip % vs Pickup Hour")
plt.show()

"""Additional analysis [optional]: Let's try comparing cases of low tips with cases of high tips to find out if we find a clear aspect that drives up the tipping behaviours"""

# Compare trips with tip percentage < 10% to trips with tip percentage > 25%

low_tip = df_financial[df_financial['tip_pct'] < 10]
high_tip = df_financial[df_financial['tip_pct'] > 25]

print("Low tipper average fare:", low_tip['fare_amount'].mean())
print("High tipper average fare:", high_tip['fare_amount'].mean())

"""**3.2.14** <font color = red>[3 marks]</font> <br>
Analyse the variation of passenger count across hours and days of the week.
"""

# See how passenger count varies across hours and days


# Avg passenger count by hour
hourly_passenger = df_financial.groupby('pickup_hour')['passenger_count'].mean()
hourly_passenger.plot(title="Average Passenger Count by Hour", ylabel="Passengers")
plt.show()

# By day of week
day_passenger = df_financial.groupby('pickup_day')['passenger_count'].mean().reindex(
    ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
)
day_passenger.plot(kind='bar', title="Average Passenger Count by Day", ylabel="Passengers")
plt.show()

"""**3.2.15** <font color = red>[2 marks]</font> <br>
Analyse the variation of passenger counts across zones
"""

# How does passenger count vary across zones
# Average passenger count by pickup zone
zone_passenger = df_financial.groupby('PULocationID')['passenger_count'].mean()

# Merge with GeoDataFrame
zones['avg_passenger_count'] = zones['LocationID'].map(zone_passenger)

# Plot map
fig, ax = plt.subplots(1, 1, figsize=(12, 10))
zones.plot(column='avg_passenger_count', ax=ax, legend=True, cmap='Blues',
           legend_kwds={'label': "Avg Passenger Count per Zone"})
plt.title("Average Passenger Count by Zone")
plt.axis('off')
plt.show()

# For a more detailed analysis, we can use the zones_with_trips GeoDataFrame
# Create a new column for the average passenger count in each zone.

"""Find out how often surcharges/extra charges are applied to understand their prevalance

**3.2.16** <font color = red>[5 marks]</font> <br>
Analyse the pickup/dropoff zones or times when extra charges are applied more frequently
"""

# How often is each surcharge applied?

surcharge_cols = ['extra', 'mta_tax', 'improvement_surcharge', 'congestion_surcharge', 'airport_fee']
for col in surcharge_cols:
    count = (df_financial[col] > 0).sum()
    print(f"{col}: Applied in {count} trips")

# Example: improvement_surcharge by hour
improvement_by_hour = df_financial[df_financial['improvement_surcharge'] > 0]['pickup_hour'].value_counts().sort_index()
improvement_by_hour.plot(kind='bar', title='Improvement Surcharge by Hour')
plt.xlabel("Hour")
plt.ylabel("Trips with Surcharge")
plt.show()

"""**Final Summary for 3.2.9 to 3.2.16: **

Analyzed fare per mile across vendors, time, and distance tiers for pricing strategy.

Identified tip behavior based on distance, passengers, and time of day.

Found patterns in passenger count by time and location.

Mapped usage frequency of surcharges to understand when/where extra fees are applied.

## **4** Conclusion
<font color = red>[15 marks]</font> <br>

### **4.1** Final Insights and Recommendations
<font color = red>[15 marks]</font> <br>

Conclude your analyses here. Include all the outcomes you found based on the analysis.

Based on the insights, frame a concluding story explaining suitable parameters such as location, time of the day, day of the week etc. to be kept in mind while devising a strategy to meet customer demand and optimise supply.

** High-Level Insights from Analysis:**
Peak Hours: 8 AM–10 AM and 5 PM–8 PM show highest ride volumes.

Busiest Days: Fridays and weekends (Saturday especially) dominate in ride counts.

High-Traffic Zones: Central Manhattan, JFK, and LaGuardia show highest pickups and dropoffs.

Slow Routes: Common between high-demand zones during peak hours (due to congestion).

Nighttime Activity: Active between 11 PM–2 AM especially in entertainment-heavy zones.

Fare vs Distance: Strong positive correlation; longer trips yield higher fares and tips.

Surcharges: Most active during weekday peaks; congestion and improvement surcharges frequently applied.

**4.1.1** <font color = red>[5 marks]</font> <br>
Recommendations to optimize routing and dispatching based on demand patterns and operational inefficiencies

**Goal**: Reduce idle time, avoid congestion, and meet demand where it's high.

**Recommendations**:
Avoid Known Slow Routes During Peak Hours

Delay dispatching through known congestion zones between 5–7 PM, particularly in Midtown Manhattan.

Use historical speed data to dynamically re-route drivers.

Pre-position Cabs Before Demand Peaks

Increase availability near major transit hubs (e.g., Grand Central, Penn Station) before 8 AM and around 4:30 PM.

Night Routing Adjustments

After 11 PM, focus routing near nightlife areas and airports where late-night travel is more likely.

Route Cabs Using Predictive Patterns

Use weekday vs weekend traffic patterns to proactively shift supply.
"""



"""**4.1.2** <font color = red>[5 marks]</font> <br>

Suggestions on strategically positioning cabs across different zones to make best use of insights uncovered by analysing trip trends across time, days and months.

**Goal**: Maximize coverage and reduce passenger wait time.

**Recommendations**:
Zone-Based Cab Allocation

Top pickup zones: Midtown, JFK, LaGuardia, Financial District — assign higher cab density here.

Low dropoff-to-pickup zones: Redirect idle cabs post-dropoff to more active locations.

Hourly Allocation

Between 11 PM and 2 AM, position cabs around entertainment areas.

Use pickup volume heatmaps to determine the optimal night vs day allocation.

Day of Week Strategy

Increase fleet size on Fridays and weekends when ride demand surges.

Reduce supply slightly mid-week during off-peak hours.

Event-Based Scaling

Use external data (sports events, concerts, weather) to pre-emptively allocate cabs in relevant zones.

**4.1.3** <font color = red>[5 marks]</font> <br>
Propose data-driven adjustments to the pricing strategy to maximize revenue while maintaining competitive rates with other vendors.

**Recommendations**:
**Tiered Pricing Strategy**

Charge slightly higher per-mile rates for 0–2 mile trips, as these have high frequency but low margins.

Offer discounts or flat rates for longer trips (e.g., >5 miles) to attract more long-distance customers.

Time-Based Fare Adjustments

Apply dynamic pricing during:

Weekday peaks (8–10 AM, 5–8 PM)

Weekend evenings

Lower prices slightly during midday lulls to boost volume.

Vendor Differentiation

Vendor 1 and 2 can price differently based on observed fare-per-mile patterns and operational efficiency.

Tip Incentive Program

Promote tip bonuses for excellent service or longer trips (high tip percentage observed on those).
"""

